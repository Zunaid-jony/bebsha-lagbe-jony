"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRuntimeDelegate = exports.getHumanFriendlyRuntimeName = exports.isValidRuntime = exports.isDeprecatedRuntime = void 0;
const node = require("./node");
const validate = require("../validate");
const error_1 = require("../../../error");
const RUNTIMES = ["nodejs10", "nodejs12", "nodejs14"];
const DEPRECATED_RUNTIMES = ["nodejs6", "nodejs8"];
function isDeprecatedRuntime(runtime) {
    return DEPRECATED_RUNTIMES.includes(runtime);
}
exports.isDeprecatedRuntime = isDeprecatedRuntime;
function isValidRuntime(runtime) {
    return RUNTIMES.includes(runtime);
}
exports.isValidRuntime = isValidRuntime;
const MESSAGE_FRIENDLY_RUNTIMES = {
    nodejs6: "Node.js 6 (Deprecated)",
    nodejs8: "Node.js 8 (Deprecated)",
    nodejs10: "Node.js 10",
    nodejs12: "Node.js 12",
    nodejs14: "Node.js 14",
};
function getHumanFriendlyRuntimeName(runtime) {
    return MESSAGE_FRIENDLY_RUNTIMES[runtime] || runtime;
}
exports.getHumanFriendlyRuntimeName = getHumanFriendlyRuntimeName;
const factories = [node.tryCreateDelegate];
async function getRuntimeDelegate(context, options) {
    const sourceDirName = options.config.get("functions.source");
    if (!sourceDirName) {
        throw new error_1.FirebaseError(`No functions code detected at default location (./functions), and no functions.source defined in firebase.json`);
    }
    validate.functionsDirectoryExists(options, sourceDirName);
    for (const factory of factories) {
        const delegate = await factory(context, options);
        if (delegate) {
            return delegate;
        }
    }
    throw new error_1.FirebaseError("Could not detect language for functions at", options.config.get("functions.source"));
}
exports.getRuntimeDelegate = getRuntimeDelegate;
